# 1000万并发购买5000库存的商品
## sql语句解决
通过sql语句控制库存为负数update s_store set amount = amount - quantity where amount>=quantity and postID = 12345'
缺点：数据库访问压力大导致的性能问题， 优点：不会出现数据错误问题，编程复杂度低
## 悲观锁（利用事物创建了排他锁）
1.select for update 缺点：从加锁到释放锁的时间不可控，死锁的机会增加
2.数据库中设计一个状态标识位，用户在对数据进行修改前，将状态标识位标识为正在编辑的状态，这样其他用户要编辑此条记录时系统将发现有其他用户正在编辑，则拒绝其编辑的请求，类似于你在操作系统中某文件正在执行，然后你要修改该文件时，系统会提醒你该文件不可编辑或删除。

## 乐观锁 数据库设计版本号（认为是可以并发访问的）
## 分布式锁（内存锁）(redis的setnx)
当某个用户要修改某个id的数据时，把要修改的id存入redis若其他用户触发修改此id的数据时，读到redis有这个id的值时，就阻止那个用户修改或等待。
问题：等待可以通过轮询实现，但是如果用户排队超时导致购买失败，但是库存中有数据，如何解决（超买解决了，如何处理并发）
解决方法：